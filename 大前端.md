# 阶段一：开启大前端的大门

## 第1周 认识大前端，开启无限可能

 万丈高楼平地起。开课第一周，我们将以轻松幽默的方式，从实际工作中的开发痛点出发，以项目全生命周期为主线，对全栈有全局的认识。从整体项目分析开始，培养您的项目架构思维。
​ 课程安排：

### 1. 了解大前端知识体系，让您有全局的认知

#### 主要内容介绍：

![图片_38](大前端.assets/图片_38.Png)



![image-20210709220204654](大前端.assets/image-20210709220204654.png)

#### 具体功能和技术栈：

![image-20210709220602114](大前端.assets/image-20210709220602114.png)



#### 界面：

![image-20210709222707954](大前端.assets/image-20210709222707954.png)

**后台：**

![image-20210709222758337](大前端.assets/image-20210709222758337.png)

**小程序：**

![image-20210709222848007](大前端.assets/image-20210709222848007.png)



**前端基础：**

1. 有扎实的 Javascript（ES6）/HTML/CSS前端功底
2. 有 Node js、Vue基础，并开发过Demo项目
3. 不少于1年的Web前端开发经验



理解大前端的定义，让您不再迷茫。

### 3. 项目规划及DevOps流程

![image-20210709224412064](大前端.assets/image-20210709224412064.png)



1. 项目定义阶段（了解）

   1. 没有明确项目的目标、资源、工期
   2. 没有进行合理的评估与预算
   3. 客户沟通不及时、不充分、不具体

2. 项目需求分析阶段（了解）

   1. 详细的需求分析，项目预算
   2. 资源计划与合理的分工
   3. 客户沟通不及时、不充分、不具体

3. **项目开发阶段（重点）**

   ![image-20210709224808769](大前端.assets/image-20210709224808769.png)

4. 项目收尾（了解）

   1. 没有规范的收尾流程，草草结束
   2. 没有对文档进行归档，对项目进行总结，形成组织资产
   3. 资源回收不及时，造成资源浪费

5. 解决方案

   1. 对组织人员培训，转变思维向自动化/规范化转型
   2. 配合效率工具（自动化）对流程进行简化/标准化
   3. 全员参与并实践

6. **Devops内容介绍（重点）**

   1. 敏捷流程

      ![image-20210807152930646](大前端.assets/image-20210807152930646.png)

   2. 整体开发流程

      ![image-20210709230724083](大前端.assets/image-20210709230724083.png)



### 4. 学习方法、自我规划、行业与公司选择

1. **如何快速提升？**
   
   1. 入门级学习方法
      - 兴趣
      - 量变到质变：从基础开始，从简单的开始：菜鸟教程；技术需要沉淀
      - 总结和分享
   2. 进阶学习
      - 知识是无边界的，术业要有专攻。踏实、谦虚的心态
      - 从单纯的做事，到对业务对需求的思考。机会会给有准备的人
      - 与同行业同年龄的人对比，补足自己的不足。木桶理论
   3. 高阶提升方法
      - 成为两（多）方面专家
      - 勇于承担与挑战，合理分配自己的时间
      - 参加交流会/技术分享大会，了解最新的知识架构
   
2. **如何选择练手的项目？**

   - 找准资源/资料，规划成片的学习时间
     - 从大纲/目标清晰的了解自己将要学习的知识，并重点看感兴趣的
     - 学会使用社区的力量

   1. **初级/入门级**
      1. 系统的视频学习：慕课网
      2. 从临摹开始；从W3 School、菜鸟教程开始
      3. 从折腾博客开始（Hexo，Jekyll，Wordpress）
   2. **中高级**
      1. 微信 cools从兴趣入手，定向发展（算法：Leetcode，基础知识：印记中文）
      2. 加入开源社区，github上的开源项目（Docker，Nodejs，AI等）
      3. 着眼中国与世界（活动日历：Google，微软，AWs，TED）

3. **前端面试中的坑**

   1. 是否一份简历通发？
      1. 是否对公司的职位及业务有所了解？
      2. 是否有过模拟自测/试？
   2. **反例中的向题**
      1. 无重要的基本信息（学历/联系方式/年龄/性别）
      2. 专业技能太空泛
      3. 项目描述不具体
   3. **面试技巧**
      1. JD 描述
      2. 简历
      3. 面试
      4. 总结
   4. **可靠的渠道**
      1. 内推/校招/实习
      2. 同学/师兄（姐）朋友关系介绍
      3. 职业猎头

4. **如何选择行业与公司？**

   行业：

   1. 看前景
   2. 看同行业的评价（薪酬、晋升、转行）
   3. 看生态（上游公司、下游公司 易跳槽）

   公司：

   1. 确定自己的定位（高薪水/高福利/高自由）
   2. 了解企业/公司团队文化
   3. 从现有的产品/岗位，了解预期的需求与发展

5. **做好自我提升规划**

   1. 现在的迷茫
      - 基础很差，背景不好，文凭不高
      - 家庭情况复杂，浑浑噩噩度日也可以！高不成，低不就的工资！
      - 年龄是一道坎，我该怎么办？性格合格吗？没有天赋可以吗？
   2. 迈出第一步
      - 与行业内的人进行交流，从基础的尝试开始
      - **了解进升的途径，设计自己的3-5年的规划**
      - 找准实践/实习的机会，做一点东西
   3. **自我提升规划**
      - 我会有一个 TodoList
      - 我会给自己的手机设置待办事项与学习提醒
      - 我会加入社区/写博客/组建团队，总结分享我的知识
      - 了解自己学习的进展速度，及时调整，抓重避轻
      - 给自己一点点暗示，或者找一个志同道合的人（男/女朋友？）
      - 培养一点兴趣与爱好，对自己好一点

### 5. 掌握需求分析的要点

- 重点知识内容
  - 项目全局思维，需求分析重难点
  - 案例项目需求分析，业务拆解、功能拆解
  - 需求分析的工具及使用场景
- 项目需求分析
  - 需求分析分析内容（从哪里来）
  - 需求分析中重点的内容（抓痛点）
  - 需求分析文档及工具（怎么做）
- 需求分析前置考虑
  - 业务型：无纸化带来的效率提升
  - 痛点型：市场决定的风声浪口
  - 功能型：企业&客户需求、解决流量入口
- 需求分析痛点
  - 不想就做
  - 照单全收
  - 未沟通/确认
  - 放羊式管理
- 需求分析的难点
  - 除了考虑功能实现，还要考虑时间/成本
  - 形成需求文档，用户回馈确认
  - 引导用户的需求，创造用户需求
- 需求分析组成部分
  - 业务需求
  - 用户需求
  - 项目需求

### 6. 本项目需求分析：从原型设计、接口设计到技术栈的宏观项目架构思维。

#### **本项目的需求分析**

- **项目要求**
  1. 全栈项目
  2. 前端痛点
  3. 企业对接
  4. 开发周期
  5. 跨端应用
  6. 多场景
- **业务需求**
  1. 社区应用（通用性强）
  2. 登录鉴权
  3. 用户体系
  4. 积分系统
  5. 发贴收藏
  6. 点赞回复
  7. 内容管理
- **用户需求**
  1. 交互简单
  2. 界面美观
  3. 运行流畅
  4. 功能实用
  5. 定制需求
  6. 其他需求
- **具体产出**
  1. 需求文档
  2. 项目选型
  3. 技术栈选型
  4. 开发周期预估
  5. 项目进度预估
  6. 分项原型图
  7. 分项流程图

- **项目需求变更**

  - 考虑是否合理
  - 是否是项目范围内的变更，对主体业务是否有影响
  - 明确需求变更的流程，确定需求变更

- **产品需求变更**

  - 沟通是王道
  - 会哭有奶吃
  - 引导需求
  - 自我挑战

- **核心业务需求分析**

  - **前端**
    - 页面/交互→组件化
    - 代码复用→工程化
    - 接口定义→标准化
  - **后端**
    - 接口开发→自动化
    - 管理后台→模块化
    - 缺陷管理→流程化
  - **业务**
    - 登录鉴权→前后分离
    - 内容展示→多场景
    - 个人中心→用户体系
  - **功能**
    - 筛选→搜索
    - 统计→积分系统
    - 评论→消息
  - **整体需求分析**
    - 前后端分离->接口鉴权->数据通用性->数据库设计
    - 内容管理->搜索->筛选->积分管理体系
    - 社区业务->权限->积分->用户体系

- **原型设计**

  - 原型：用线条、图形描绘出的产品框架，也称线框图
  - 设计：综合考虑产品目标、功能需求场景、用户体验等因素，对产品的各版块、界面和元素进行的合理性排序过程。
  - **产品阶段**：想法→需求采集→功能结构→原型设计→产品需求文档

  - 原型设计是清晰的表达系统的构想

- **原型设计的目标**

  - 展现布局逻辑结构
  - 表明状态关系与跳转关系
  - 低成本的快速修改

#### **PC端需求分析**

- 内容展示
- 回复/点赞
- 积分与用户体系

![image-20210807164536446](大前端.assets/image-20210807164536446.png)

- Axure 实现原型图

![image-20210807165048710](大前端.assets/image-20210807165048710.png)



- **PC端文档产出**
  - PC端重要页面原型图
  - PC端主体页面流程图
  - 说明文档`.md`（MarkDown文件）

#### 服务端需求分析

- 用户、权限管理
- 内容管理、首页管理
- 其他功能（日志、多语言等）

![image-20210807165630878](大前端.assets/image-20210807165630878.png)

#### WebApp和小程序原型设计

- 主体功能
  - 重PC端，手机端功能少
- 技术实现/交互体验
- 用户数据与流量入口



- **原型设计**
  - 墨刀

![image-20210807170415346](大前端.assets/image-20210807170415346.png)



- **WebApp，小程序文档产出**
  - 重要页面原型图
  - 主体页面流程图及跳转逻辑
  - 说明文档`.md`（MarkDown文件）



#### 技术栈选择

- 团队技术实力与业务需求结合
- 能够复用，坚决不造轮子；需要造轮子，坚决不牵强
- 怎么简单怎么来，多考虑时间、进度、质量因素

![image-20210709220602114](大前端.assets/image-20210709220602114.png)



### 7. 需求分析工具：墨刀/Axure

- 原型类：**Axure**，Ps，**墨刀**，蓝湖
- 思维脑图：**Xmind**，Mindnode（Mac），MindManager
- 流程图：Visio（win）/OmniGraffle（Mac）/**processOn**

#### Axure

- 类似于矢量设计软件，内置了浏览器相关操作，需要安装插件。
- https://www.axure.com/downloadthanks

#### 墨刀

- 在线操作，在线分享，收费。可免费简单使用。
- 相比Axure，模板多。支持手机模板。
- https://modao.cc/downloads

#### Xmind

- 操作简单，已熟练。
- https://www.xmind.net/download/

#### processOn

- 在线流程图，收费。可免费简单使用。
- https://www.processon.com/



## 第2周 企业标准的开发环境搭建

工欲善其事，必先利其器。学习最火的Docker容器技术，快速搭建测试环境。深入讲解前端必会的Mock接口与工具，并专门设计了调试技巧&真机调试讲解，与实际工作开发完美契合。
​ 课程安排：

### **开发环境准备：**

无法访问GitHub问题：

```
sodu vim /etc/hosts

dns1.p08.nsone.net github.com
185.199.108.133 raw.githubusercontent.com
11 185.199.108.133 user-images.githubusercontent.com
12 185.199.108.133 avatars2.githubusercontent.com
13 185.199.108.133 avatars1.githubusercontent.com
```



#### Node.js

- Node.js（npm/yarn）+ nvm（Node.js版本管理）

- [如何正确使用淘宝npm镜像](https://segmentfault.com/a/1190000027083723)

- `npm install -g cnpm --registry=https://registry.npm.taobao.org`

- 因为在此系统上禁止运行脚本。

  - `get-executionpolicy`： Restricted 执行策略不允许任何脚本运行。 
  - 以管理员身份打开PowerShell 输入 `set-executionpolicy remotesigned`

- **NVM （Node.js版本管理）**

  - [在linux上为所用用户安装 NVM](https://segmentfault.com/a/1190000019929765)
  - [使用nvm安装nodejs](https://segmentfault.com/a/1190000020807954)
  - Linux 换源：`export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node/`
  - [官方安装和卸载教程](https://github.com/nvm-sh/nvm)

- **yarn**

  - 支持在线安装、离线安装，更快。

  - ```
    npm install --global yarn
    yarn config set registry 'https://registry.npm.taobao.org/'
    ```

  - https://classic.yarnpkg.com/en/docs/install/#debian-stable

  - #### [中文文档](https://yarn.bootcss.com/docs/)

- IDE
  - IDE（Webstorm/**Vscode**/Atom）
- Vue-CLi
  - 安装命令：`npm install -g @vue/cli`
  - 快速原型开发：`npm install -g @vue/cli-service-global`

- 测试环境
  - 虚拟机自建环境（Parallels/Vmware/Hyperv）
  - Linux
    1. 查看Linux内核版本信息
       - 方法1：登陆Linux，在终端输入 cat /proc/version
       - 方法2：登陆Linux，在终端输入 uname -a
       - 方法3：登陆Linux，在终端输入 uname -r
       - `uname -srm`
    2. 查看Linux系统版本信息
       - 方法1：登陆Linux，在终端输入 cat /etc/issue
       - 方法2：登陆Linux，在终端输入 cat /etc/lsb-release
       - 方法3：登陆Linux，在终端输入 lsb_release -a
    3. 查看cpu信息
       - 输入命令：more /proc/cpuinfo

#### 安装 Docker

- #### 卸载旧版本

  泊坞窗的旧版本被称为`docker`，`docker.io`或`docker-engine`。如果安装了这些，请卸载它们：

  ```
  $ sudo apt-get remove docker docker-engine docker.io containerd 
  ```

- #### 设置存储库

  1. 更新`apt`包索引并安装包以允许`apt`通过 HTTPS 使用存储库：

     ```
     $ sudo apt-get update
     
     $ sudo apt-get install \
         apt-transport-https \
         ca-certificates \
         curl \
         gnupg \
         lsb-release
     ```

  2. **添加Docker官方的GPG密钥：** 必须！

     ```
     $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
     ```

  3. 使用以下命令设置**稳定**存储库。要添加 **每晚**或**测试**存储库，请在以下命令中的单词后添加单词`nightly`或`test`（或两者）`stable`。[了解**nightly**和**test**频道](https://docs.docker.com/engine/install/)。

     ```
      echo \
       "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
       $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
     ```

     

- #### 安装 Docker 引擎

  1. 更新`apt`包索引，安装*最新版本*的Docker Engine和containerd，或者到下一步安装特定版本：

     ```
      $ sudo apt-get update
      $ sudo apt-get install docker-ce docker-ce-cli containerd.io
     ```

     > 有多个 Docker 存储库？
     >
     > 如果您启用了多个 Docker 存储库，则在`apt-get install`或 `apt-get update`命令中未指定版本的情况下安装或更新始终会安装可能的最高版本，这可能不适合您的稳定性需求。

  2. 要安装*特定版本*的 Docker Engine，请在 repo 中列出可用版本，然后选择并安装：

     一种。列出您的存储库中可用的版本：

     ```
     $ apt-cache madison docker-ce
     
       docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
       docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
       docker-ce | 18.06.1~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
       docker-ce | 18.06.0~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
     ```

     湾 使用第二列中的版本字符串安装特定版本，例如`5:18.09.1~3-0~ubuntu-xenial`.

     ```
     $ sudo apt-get install docker-ce=<VERSION_STRING> docker-ce-cli=<VERSION_STRING> containerd.io
     ```

  3. 通过运行`hello-world` 映像验证 Docker Engine 是否已正确安装。

     ```
     $ sudo docker run hello-world
     ```

     此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。

- #### Install Docker Compose

  - https://docs.docker.com/compose/install/

  - 运行此命令以下载 Docker Compose 的当前稳定版本：

    ```
    $ sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    ```

    > 要安装不同版本的 Compose，请替换`1.29.2` 为您要使用的 Compose 版本。

    如果您在安装时遇到问题`curl`，请参阅 上面的[替代安装选项选项](https://docs.docker.com/compose/install/#alternative-install-options)卡。

  - 对二进制文件应用可执行权限：

    ```
    $ sudo chmod +x /usr/local/bin/docker-compose
    ```

  > **注意**：如果`docker-compose`安装后命令失败，请检查您的路径。您还可以`/usr/bin`在路径中创建指向或任何其他目录的符号链接。

  例如：

  ```
  $ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
  ```

  1. 或者，安装[命令完成](https://docs.docker.com/compose/completion/)了 `bash`和`zsh`外壳。

  2. 测试安装。

     ```
     $ docker-compose --version
     ```

- 数据库服务

#### MongoDB

- https://hub.docker.com/_/mongo

- `docker pull mongo`

  - 换源：`https://docs.docker.com/registry/recipes/mirror/#configure-the-docker-daemon`

- Robo 3T

  - `robomongo.org/download`

- #### 启动一个`mongo`服务器实例

  ```console
  $ docker run --name some-mongo -d mongo:tag
  ```

  `some-mongo`您要分配给容器的名称在哪里，是`tag`指定您想要的 MongoDB 版本的标签。

- #### 从另一个 Docker 容器连接到 MongoDB

  镜像中的 MongoDB 服务器侦听标准 MongoDB 端口`27017`，因此通过 Docker 网络连接将与连接到远程`mongod`. 以下示例启动另一个 MongoDB 容器实例，并`mongo`针对上述示例中的原始 MongoDB 容器运行命令行客户端，从而允许您针对数据库实例执行 MongoDB 语句：

  ```console
  $ docker run -it --network some-network --rm mongo mongo --host some-mongo test
  ```

  ...`some-mongo`原始`mongo`容器的名称在哪里。

  - 教程使用：`docker run -d --name some-mongo -p 10050:27017 mongo:latest`
  - 删除：`docker rm some-mongo`
  - 停止：`docker stop some-mongo`

- **关闭防火墙**
  - Ubuntu：service ufw stop
    - 添加到放行规则：ufw allow Port端口号
    - `firewall-cmd --reload`
  - Centos：service firewall stop



### 1. 虚拟机搭建与使用

#### 虚拟机

1. Windows 
   - Vmware
   - Hyper-V
2. Mac OS
   - Parallels
3. Linux
   - Centos虚拟化模块

#### Linux

1. 版本
   - `lsb_release -a`
   - `uname -a`
2. 目录结构
   1. 以Mb为单位查看磁盘空间：` df -Th`
   2. `cd /`
      - `ls -la`
3. 文件权限
   - `drwxr-xr-x  19 root root      4180 Aug  8 00:24 dev`
     - 目录读写执行：d 用户权限 组权限 其它权限
     - root 用户 root 组 文件大小 时间 文件名
4. 硬件/性能

### 2. Linux开发环境及常见命令使用

#### Linux 目录

- 根目录
  - `/bin` 
    - 可执行二进制文件
  - `/etc` 
    - 配置文件
  - `/home` 
    - 用户文件主目录
    - `home/user`
      - user 用户的主目录
  - `/usr` 
    - 系统应用目录
    - `/usr/local/`
      - 管理员安装的软件目录
      - `/usr/local/bin`
        - 二进制可执行文件
      - `/usr/local/etc`
        - 用户安装的软件配置目录
  - `/opt` 
    - 额外安装的可选应用程序包所放置的位置
  - `/proc` 
    - 虚拟文件系统, 系统内存映射, 系统所有信息, Linux一切皆是文件
      - 数字是进程
      - 设备/软件等进程
  - `/dev` 
    - 用于存放设备文件
  - `/mnt` 
    - 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系
  - `/lib` 
    - 存放跟文件系统中的程序运行所需要的共享库及内核模块
  - `/var`
    - 用于存放运行时需要改变数据的文件
  - `/boot`
    - 存放用于系统引导时使用的各种文件
  - `/sbin`
    - 存放二进制可执行文件，只有root才能访问
  - `/root`
    - 超级用户（系统管理员）的主目录

#### Linux 文件常用操作

- 创建
  - 创建文件
    - `touch [文件名]`
  - 创建文件夹
    - `mkdir [文件名]`
- 查看
  - `ls -al` 查看当前目录详情
  - `cat [文件名]`  查看文件
- 删除
  - `rm [文件名]`
  - 删除文件夹
    - `rm -r [文件夹]` 递归删除
    - `rm -rf [文件夹]` 递归强制删除
- 写入
  - `vim [文件名]`
  - `echo "内容" >> [文件名] ` 追加内容
  - `echo "内容" > [文件名] ` 覆盖内容
- 下载
  - `wget [url]`
- 解压
  - `tar [操作] [文件名]` 
    - `tar zxvf linux-gtk.tar.gz  ` 
    - `z`：gz 压缩包
    - `x`：解压缩
    - `v`：显示过程
    - `f`：用包名作为文件夹名
- 压缩
  - `tar [操作] [文件名] [目录]` 
    - `tar zcvf linux-gtk.tar.gz linux-gtk  ` 
    - `c`：压缩

#### Linux 进程相关命令

- 只显示过滤的进程。

  - ```
    ps [options] | grep [options]
    ```

  - `ps -ef|grep docker`

- 实时显示进程

  - `top`
    - `m`：内存占用
    - `c`：cpu占用

- 停止进程

  - `kill 9 [pid]`

- 查看服务状态

  - `service sshd status`
  - 关闭
    - `service sshd stop`
    - `restart`
  - `systemctl status sshd`



#### 文件建立、复制、删除和移动命令

**mkdir 命令使用格式**

格式： `mkdir [选项] DirName`

- 通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限([了解Linux文件-文件夹权限请点击这里](http://it.dengchao.org/linux-fedora-ubuntu-file/linux/))。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。
- `mkdir  777  /home/cc/it.dengchao.org`



 **cp 命令使用格式**

　　语法： `cp [选项] 源文件或目录 目标文件或目录`

- 该命令的功能是将给出的文件或目录拷贝到另一文件或目录中，就如同DOS下的copy命令一样，功能非常强大。
-  `-r` 若给出的源文件是一目录文件，此时 cp 将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。



 **mv 命令使用格式**

　　语法：`mv [选项] 源文件或目录 目标文件或目录`

- 用户可以使用mv命令来为**文件或目录改名或将文件由一个目录移入另一个目录中**。该命令如同DOS下的ren和move的组合。



 **rm 命令使用格式**

​		语法：`rm [选项] 文件`

- 在linux中创建文件很容易，系统中随时会有文件变得过时且毫无用处。用户可以用rm命令将其删除。该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。
- `-r` 指示rm将参数中列出的全部目录和子目录均递归删除。



#### Linux ssh 密钥登录

- [如何在Ubuntu 20.04上设置SSH密钥](https://www.myfreax.com/how-to-set-up-ssh-keys-on-ubuntu-20-04/)

  ```shell
  #客户机：
  ssh-keygen -t rsa -b 4096 -C "your_email@domain.com"
  
  Enter file in which to save the key (/home/yourusername/.ssh/id_rsa):
  
  Enter passphrase (empty for no passphrase):
  
  ls ~/.ssh/id_*
  #您已经在Ubuntu客户端计算机上成功生成了SSH密钥对。
  
  
  #将公钥复制到远程服务器：
  ssh-copy-id remote_username@server_ip_address
  
  remote_username@server_ip_address's password:
  
  #如果由于某些原因您的本地计算机上没有ssh-copy-id实用程序，请使用以下命令复制公钥：
  cat ~/.ssh/id_rsa.pub | ssh remote_username@server_ip_address "mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys"
  ```



#### Linux Git 配置

[ubuntu git环境搭建以及通过SSH连接Github（免密码）配置](https://segmentfault.com/a/1190000013154540)



#### Linux 环境变量配置

通过 `yarn global add xxx` 安装的模块，命令无法识别

解决：

1. 使用 `yarn global bin` 命令，获得命令所在目录
2. 将获得的目录路径加入到环境变量中

Linux:

```shell
echo export PATH="\"\$PATH:$(yarn global bin)\"" >> ~/.bashrc
source ~/.bashrc
```

或者：

```shell
# 加到PATH末尾
export PATH=$PATH:/path/to/your/dir
export PATH=$PATH:/home/ubuntu/.yarn/bin

# 加到PATH开头
export PATH=/path/to/your/dir:$PATH
```

**新的环境变量**

也可以直接命名一个新的环境变量，用于其它程序引用：

```shell
export VAR_NAME=value
```

如果只需要添加的环境变量**对当前用户有效**，可以写入用户主目录下的`.bashrc`文件：

```shell
vim ~/.bashrc
```

要使环境变量**对所有用户有效**，可以修改`profile`文件：

```shell
sudo vim /etc/profile 
```

添加语句：

```shell
export CLASS_PATH=./JAVA_HOME/lib:$JAVA_HOME/jre/lib
```

注销或者重启可以使修改生效，如果要使添加的环境变量马上生效：

```shell
source /etc/profile
```

#### Ubuntu 网络图标消失

**现象描述：**Ubuntu 网络图标消失，无法联网

**整体思路：**

已经尝试过删除network-manager的缓存文件，没有解决问题。

1、删除NetworkManager缓存文件

```text
service NetworkManager stop
sudo rm /var/lib/NetworkManager/NetworkManager.state
service NetworkManager start
```

2、修改/etc/NetworkManager/NetworkManager.conf

```text
managed=true
```

3、重启NetworkManager

```text
sudo service network-manager restart
```



### 3. 容器技术Docker以及安装及使用

#### 容器化应用

![image-20210809092923925](大前端.assets/image-20210809092923925.png)

#### Docker主要特性

- 文件、资源、网络隔离
- 变更管理、日志记录
- 写时复制
  - 快速部署



#### 实机演示

- 命令
  - `docker --help`
  - `docker logs -f [name] `
  - `docker run --name imooc-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 28001:3306 -d mysql`
    - 会自动拉取镜像，忽略tag为最新版。



#### Docker Compose

- 借助 Compose，您可以使用 YAML 文件来配置应用程序的服务。然后，使用单个命令，从配置中创建并启动所有服务。要了解有关 Compose 的所有功能的更多信息，请参阅[功能列表](https://docs.docker.com/compose/#features)。

- 使用 Compose 基本上是一个三步过程：

  1. 使用 定义您的应用程序的环境，`Dockerfile`以便它可以在任何地方复制。
  2. 定义组成您的应用程序的服务，`docker-compose.yml` 以便它们可以在隔离的环境中一起运行。
  3. 运行`docker compose up`和 [cli-command 命令](https://docs.docker.com/compose/cli-command/)启动并运行你的整个应用程序。您也可以`docker-compose up`使用 docker-compose 二进制文件运行。
     - `docker-compose up -d`
     - `docker-compose stop`
     - `docker-compose rm`

  - `docker-compose.yml`看起来像这样：

  ```
  version: "3.9"  # optional since v1.27.0
  services:
    web:
      build: .
      ports:
        - "5000:5000"
      volumes:
        - .:/code
        - logvolume01:/var/log
      links:
        - redis
    redis:
      image: redis
  volumes:
    logvolume01: {}
  ```

  有关 Compose 文件的详细信息，请参阅 [Compose 文件参考](https://docs.docker.com/compose/compose-file/)。

  Compose 具有用于管理应用程序整个生命周期的命令：

  - 启动、停止和重建服务
  - 查看正在运行的服务的状态
  - 流式传输正在运行的服务的日志输出
  - 对服务运行一次性命令



#### Docker仓库（Docker hub及私有仓库 Harbor）

- 注册账号
  - 提交：`docker commit [container ID] [userID/tagName:tag]`
  - 推送：`docker push [userID/tagName:tag]`
  - 拉取：`docker pull [userID/tagName:tag]`



### 4. Node及npm命令的使用

- 免费、开源、跨平台（Windows、Linux、Mac OS X，etc）
- 服务器上的 Javascript运行环境
- 基于 Chrome v8引擎，事件驱动、非阻塞式I/O



#### npm发布包

- `npm init`
  - `npm adduser`
  - `npm whoami`
  - `npm publish`
- [npm常用命令和换源](https://www.jianshu.com/p/087d839e1d0c)



#### NPM 使用介绍

新版的nodejs已经集成了npm，所以之前npm也一并安装好了

```shell
$ npm -v

#升级
$ sudo npm install npm -g
```

**npm 安装 Node.js 模块语法格式如下：**

```shell
$ npm install <Module Name>

$ npm install express
```

**全局安装与本地安装**

```shell
npm install express          # 本地安装
npm install express -g   # 全局安装

# 设置代理为空
$ npm config set proxy null
```

通过 `require()` 来引入本地安装的包。

**查看所有全局安装的模块：**

```
$ npm ls -g
```

**卸载 Node.js 模块：**

```
$ npm uninstall express
```

**更新模块：**

```
$ npm update express
```

**搜索模块：**

```
$ npm search express
```

**创建模块：**

```
$ npm init
$ npm adduser
$ npm publish
```



#### Package.json 属性说明

- **name** - 包名。
- **version** - 包的版本号。
- **description** - 包的描述。
- **homepage** - 包的官网 url 。
- **author** - 包的作者姓名。
- **contributors** - 包的其他贡献者姓名。
- **dependencies** - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。
- **repository** - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。
- **main** - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require("express")。
- **keywords** - 关键字



#### npm --save-dev --save 的区别

`npm install` 在安装`npm` 包时，有两种命令参数可以把它们的信息写入 `package.json` 文件

```json
{
 "dependencies": {
    "vue": "^2.2.1"
  },
  "devDependencies": {
    "babel-core": "^6.0.0",
    "babel-loader": "^6.0.0",
    "babel-preset-latest": "^6.0.0",
    "cross-env": "^3.0.0",
    "css-loader": "^0.25.0",
    "file-loader": "^0.9.0",
    "vue-loader": "^11.1.4",
    "vue-template-compiler": "^2.2.1",
    "webpack": "^2.2.0",
    "webpack-dev-server": "^2.2.0"
  }
}
```

`dependencies`是**运行时依赖**，`devDependencies`是**开发时的依赖**。

**默认安装到运行时依赖。** `-D` 重新安装会自动移动到`devDependencies`，再 `-S` 无法移动回去，需要先卸载。

`npm install name -save-dve` 简写（**`npm install name -D`**） 自动把模块和版本号添加到`devdependencies`。

`npm install name -save` 简写（**`npm install name -S`**） 自动把模块和版本号添加到`dependencies`。



### 5. 前后端分离开发--RESTful接口及Mock数据

#### RESTful api介绍

- REST--REpresentational State Transfer英语的直译就是“表现层状态转移”。
  - Resource-based：资源，即数据。
  - Representational：某种表现形式，比如用SON，XML，JPEG等
  - StateTransfer：状态变化。通过HTTP动词实现
- 客户端 - 服务端
  - 通过将用户界面，让数据与存储分开，通过简化服务器组件来实现跨多平台的应用
- 无状态，可缓存
  - C->S 包含理解请求所需的所有信息。
- 统一接口
  - 语义化接口
  - 定义数据类型
- **RESTful api 即为 REST 风格的 /REST 特点的应用接口。**

#### 4 种常见的接口测试工具对比

- 插件类
  - **Postman**，dhc，rest client
- 平台类
  - Yapi，**DOClever**，RAP2，Easy Mock，Swagger
- 终端类
  - Postman，**SoapUI**，doclever



#### 什么是Mock数据，Mock数据开发介绍

- 模拟真实接口
  - 实现效率开发，前后台同步，特别是分布式的系统
- 虚拟业务场景
  - 某些开发场景非常难触发，还有一些异常逻辑、交互逻辑
- 压力测试



### 6. 搭建DOClever接口测试平台

- Mock数据开发流程介绍
  - 前端定义接口
  - 完成静态页面
  - 完成UI交互
  - 对接真实接口
  - 页面/逻辑测试
  - 线上部署

#### DOClever安装—docker安装介绍

- [DOClever Docker 镜像 安装教程](https://hub.docker.com/r/lw96/doclever)

```
建议使用docker-compose进行容器的管理

version: "2"
services:
  DOClever:
    image: lw96/doclever
    restart: always
    container_name: "DOClever"
    ports:
    - 10000:10000
    volumes:
    - /本地路径/file:/root/DOClever/data/file
    - /本地路径/img:/root/DOClever/data/img
    - /本地路径/tmp:/root/DOClever/data/tmp
    environment:
    - DB_HOST=mongodb://mongo:27017/DOClever
    - PORT=10000
    links:
    - mongo:mongo

  mongo:
    image: mongo:latest
    restart: always
    container_name: "mongodb"
    volumes:
    - /my/own/datadir:/data/db
    
    
对上面代码的说明：

volumes：代表着把容器中的数据挂载到你本地路径，本地路径

environment: 环境变量。 (1)DB_HOST：可以使用自定义数据库地址，或者使用容器中的mongodb (2)PORT：中设置的端口号10000为容器中的端口（尽量不变，只修改容器暴露的端口号，即ports下面的端口），而外部的端口可以自定义。

ports:容器暴露的实际端口 比如： ports:

自己想设置的端口:10000

```

- 启动命令

```
docker run -it -d --name doclever -p 10000:10000 \
-e DB_HOST=mongodb://localhost:27017/DOClever \
-e PORT=10000 \
-e DB_FILE=/root/DOClever/data/file \
-e DB_IMG=/root/DOClever/data/img \
-e DB_TEMP=/root/DOClever/data/tmp \
-v /srv/doclever/file:/root/DOClever/data/file \
-v /srv/doclever/img:/root/DOClever/data/img \
-v /srv/doclever/tmp:/root/DOClever/data/tmp \
lw96/doclever:latest-ubuntu
```



- 配置文件

```yml
  1 rersion: "3.9"  # optional since v1.27.0
  2 services:
  3   DOClever:
  4     image: lw96/doclever
  5     restart: always
  6     container_name: "DOClever"
  7     ports:
  8     - 10000:10000
  9     volumes:
 10     - /srv/doclever/file:/root/DOClever/data/file
 11     - /srv/doclever/img:/root/DOClever/data/img
 12     - /srv/doclever/tmp:/root/DOClever/data/tmp
 13     environment:
 14     - DB_HOST=mongodb://mongo:27017/DOClever
 15     - PORT=10000
 16     links:
 17     - mongo:mongo
 18   mongo:
 19     image: mongo:latest
 20     restart: always
 21     ports:
 22     - "27017:27017"
 23     container_name: "mongodb"

```

- 防火墙开放端口
- 管理总后台登录：默认密码：`DOClever`
- 使用方法：

![image-20210810212017439](大前端.assets/image-20210810212017439.png)

- postman 测试：

![图片_60](大前端.assets/图片_60.Png)

- DOClever中Mock数据开发使用简介
  - [官方文档](http://doclever.cn/)

#### 使用 Mock.js 本地 Mock

- 拦截 Ajax 请求，按要求生成随机数据
- [安装和使用-官方文档](https://github.com/nuysoft/Mock/wiki/Getting-Started)
  - 引入文件，写在 JS 代码里拦截。



### 7. 常见IDE使用及VSCode的调试配置及默认设置

集成开发环境（IDE，Integrated Development Environment）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。

- 外观
- 智能
- 插件
- 设置
  - VScode 快捷键：ctrl+p, >key, 快捷键参考 
- 调试

[Ubuntu 安装 WebStorm 教程](https://linuxhint.com/install_jetbrains_webstorm_ubuntu/)

快捷方式和终端启动：

![图片_56](大前端.assets/图片_56.Png)



### 8. 三类真机调试技巧

- Chrome +Android/ Safari iOS
  - 真机连接调试
- Fiddler（win） /Charles（mac）
  - 劫持调试
  - 类似于控制台 Network
- **Weinre**, Spy-Debugger, vConsole



## 第3周 必会的前端工程化工具

 效率是检验工程师的重要指标之一，如何提高开发效率，从前端工程化工具着手。本周学习实际工作中两大利器Webpack与Gulp，并使用Yeoman搭建自己的脚手架工具，让自己和团队的开发效率翻倍。
​ 课程安排：

### 1. 了解工程化工具的使用场景及具体应用

#### 什么是前端工程化？

- 前端工程化是指将前端开发的流程规范化、标准化，
- 包括开发流程、技术选型、代码规范、构建发布等，
- 用于提升前端工程师的开发效率和代码质量。

![image-20210811110208802](大前端.assets/image-20210811110208802.png)

#### 为什么要前端工程化？

- 复杂度高：前端项目的多功能、多页面、多状态、多系统
- 规模大：团队开发，多人协作，代码质量管理
- 要求高：页面性能优化（CDN异步加载/倩请求合并），CSS兼容性、单页面应用、服务端渲染...

#### 怎么做到前端工程化？

- 从业务着手
  - 简单的单页面应用，使用gulp打包+同步工具实现开发全流程
- 从复杂度考虑
  - jenkens git/gitlab webpack React/Vue/Angular
- 从已知向未知扩展
  - 不同的技术有不同的适应点，选择适合的才是最好的

- 考虑
  - 前后端技术是否更好的融合
  - 前后端分离，接口安全性
  - vue或 react是否适合制作静态页面
  - php是否更好的集合
- 最佳实践
  - 组件化/脚手架/工程Cli工具
  - Git flow
  - webpack
  - Jenkins+docker

### 2. 理解Webpack的核心概念，配置Webpack

[Webpack 中文文档](https://webpack.docschina.org/concepts/)

打包工具：

![image-20210811112013390](大前端.assets/image-20210811112013390.png)

- 入口
- 输出
- Loader
  - babel 
  - 处理非 JS 文件
- 插件
  - HtmlWebpackPlugin
- 模式/兼容性
  - webpack支持所有符合ES5标准的浏览器（不支持I8及以下版本）。webpack的 import() 和 require.ensure() 需要 Promise。
  - 如果你想要支持旧版本浏览器，在使用这些表达式之前，还需要提前加载 polyfill

#### [安装指南（重要）](https://webpack.docschina.org/guides/getting-started/)

- 在安装一个 package，而此 package 要打包到生产环境 bundle 中时，你应该使用 `npm install --save`。如果你在安装一个用于开发环境的 package 时（例如，linter, 测试库等），你应该使用 `npm install --save-dev`。

```shell
mkdir webpack-demo
cd webpack-demo
npm init -y # 快速创建 node.js 项目
npm install webpack webpack-cli --save-dev

# npm install webpack webpack-cli -D # -D --save-dev 开发模式，不会打包

# 全局安装
npm install webpack webpack-cli -g # -g 全局安装

yarn add webpack -webpack-cli -D
yarn global add webpack -webpack-cli -D
```

- 全局安装可直接使用 `webpack`

- 在 `package.json` 输入，使用 `npm run build` 运行 webpack

  ```json
  {
    "name": "webpack-demo",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
      "build": "webpack"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "devDependencies": {
      "webpack": "^5.50.0",
      "webpack-cli": "^4.7.2"
    }
  }
  ```

#### `npx` 命令：

- `npx` 会帮你执行依赖包里的二进制文件。
- `npx webpack --version`

```shell
# 项目的根目录下执行
$ node-modules/.bin/mocha --version

# npx 就是想解决这个问题，让项目内部安装的模块用起来更方便
$ npx mocha --version

# 由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。
# 等同于 ls
$ npx ls

# 除了调用项目内部模块，npx 还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx 可以运行它，而且不进行全局安装。
$ npx create-react-app my-react-app
# 上面代码运行时，npx 将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。
```

#### Win + VSCode + Ubuntu 开发

[VSCode Remote-SSH 连接远程服务器完成开发/编辑文件](https://blog.csdn.net/wuyujin1997/article/details/105620836)

Linux环境下的VSCode，执行命令为`code`
打开文件 `code file_name`
打开文件夹 `code dir_name`，不过会在新的VSCode窗口打开。

在本地终端输入一行指令即可打开远程文件。具体为

```bash
code --remote ssh-remote + <remote_name> <remote_path>
```

其中，`remote_name`为在`.ssh/config`中配置的远程服务器别名，`remote_path`为要打开的远程服务器上的绝对路径。



#### 入口与输出

- 入口

  - **入口起点(entry point)** 指示 webpack 应该使用哪个模块，来作为构建其内部 [依赖图(dependency graph)](https://webpack.docschina.org/concepts/dependency-graph/) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。

    默认值是 `./src/index.js`，但你可以通过在 [webpack configuration](https://webpack.docschina.org/configuration) 中配置 `entry` 属性，来指定一个（或多个）不同的入口起点。

  - **webpack.config.js**

    ```javascript
    module.exports = {
      entry: './path/to/my/entry/file.js',
    };
    ```

- 输出

  - **output** 属性告诉 webpack 在哪里输出它所创建的 *bundle*，以及如何命名这些文件。主要输出文件的默认值是 `./dist/main.js`，其他生成文件默认放置在 `./dist` 文件夹中。

    你可以通过在配置中指定一个 `output` 字段，来配置这些处理过程：

    **webpack.config.js**

    ```javascript
    const path = require('path');
    
    module.exports = {
      entry: './path/to/my/entry/file.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'my-first-webpack.bundle.js',
      },
    };
    ```

    

- 关键词 entry，output 
  - webpack 配置文件 `webpack.config.js` 
- Node 的路径相关：
  - Path 模块的使用使用 require进行引入，
  - webstorm 配置 node core 
- Output 中的`path`需要使用**绝对路径** 
  - `path.join` 去拼接路径，Nodes全局变量 `__dirname`



### 3. 掌握Webpack中的Plugin及Loader的使用

#### [loader 概念](https://webpack.docschina.org/concepts/#loaders)

webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。

**loader** 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 [模块](https://webpack.docschina.org/concepts/modules)，以供应用程序使用，以及被添加到依赖图中。

> 注意，loader 能够 `import` 导入任何类型的模块（例如 `.css` 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是很有必要的，因为这可以使开发人员创建出更准确的依赖关系图。

在更高层面，在 webpack 的配置中，**loader** 有两个属性：

1. `test` 属性，识别出哪些文件会被转换。
2. `use` 属性，定义出在进行转换时，应该使用哪个 loader。

**webpack.config.js**

```javascript
const path = require('path');

module.exports = {
  output: {
    filename: 'my-first-webpack.bundle.js',
  },
  module: {
    rules: [{ test: /\.txt$/, use: 'raw-loader' }],
  },
};
```

以上配置中，对一个单独的 module 对象定义了 `rules` 属性，里面包含两个必须属性：`test` 和 `use`。这告诉 webpack 编译器(compiler) 如下信息：

> “嘿，webpack 编译器，当你碰到「在 `require()`/`import` 语句中被解析为 '.txt' 的路径」时，在你对它打包之前，先 **use(使用)** `raw-loader` 转换一下。”



#### [loader 示例](https://webpack.docschina.org/concepts/loaders/#example) 

首先安装相对应的 loader：

```
npm install --save-dev css-loader ts-loader
```

然后指示 webpack 对每个 `.css` 使用 [`css-loader`](https://webpack.docschina.org/loaders/css-loader)，以及对所有 `.ts` 文件使用 [`ts-loader`](https://github.com/TypeStrong/ts-loader)：

**webpack.config.js**

```
module.exports = {
  module: {
    rules: [
      { test: /\.css$/, use: 'css-loader' },
      { test: /\.ts$/, use: 'ts-loader' },
    ],
  },
};
```

```shell
$ npm install css-loader style-loader -D
$ npm install sass-loader node-sass -D

# npm uninstall css-loader csv-loader json5 style-loader toml xml-loader yamljs
```

- 浏览器缓存了脚本，导致看不到修改：`<script src="main.js"></script>`
  - 在控制台 network 里禁用缓存

#### [管理资源](https://webpack.docschina.org/guides/asset-management/)

webpack 最出色的功能之一就是，除了引入 JavaScript，还可以通过 loader 或内置的 [Asset Modules](https://webpack.docschina.org/guides/asset-modules/) *引入任何其他类型的文件*。也就是说，以上列出的那些 JavaScript 的优点（例如显式依赖），同样可以用来构建 web 站点或 web 应用程序中的所有非 JavaScript 内容。

模块 loader 可以链式调用。链中的每个 loader 都将对资源进行转换。链会逆序执行。第一个 loader 将其结果（被转换后的资源）传递给下一个 loader，依此类推。最后，webpack 期望链中的最后的 loader 返回 JavaScript。



#### 插件(plugin) 

- 打包优化，资源管理，注入环境变量。

- 想要使用一个插件，你只需要 `require()` 它，然后把它添加到 `plugins` 数组中。多数插件可以通过选项(option)自定义。
- 你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 `new` 操作符来创建一个插件实例。

**`html-webpack-plugin`**

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: {
    index: './src/index.js',
    print: './src/print.js',
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: '管理输出',
      filename: 'index.html',
      template: './src/template.html'
    }),
  ],
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
    clean: true,
  },
};
```



#### HMR 启用模块热更新 

package.json

```json
"scripts": {
    "build": "webpack",
    "watch": "webpack --watch",
    "serve": "webpack serve"
  },
```

[devServer 配置文件](https://webpack.docschina.org/configuration/dev-server/#devserver)

`HMR` 的启用十分简单，一个带有热更新功能的 `webpack.config.js` 文件的配置如下：

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: {
    index: './src/index.js',
  },
  devServer: {
    contentBase: path.resolve(__dirname, 'dist'),
    hot: true,
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      filename: 'index.html',
      template: './src/template.html'
    }),
  ],
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
    clean: true,
  },
};
```

`src/index.js`

```javascript
if (module.hot) {
    module.hot.accept();
}
```



#### [mode 模式](https://webpack.docschina.org/configuration/mode/) 

```
mode: 'development',
```



#### [babel](https://www.babeljs.cn/docs/usage)

- [@babel/plugin-transform-runtime](https://www.babeljs.cn/docs/babel-plugin-transform-runtime) 

```shell
$ yarn add babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime -D
$ yarn add @babel/runtime -S
```

- [clean-webpack-plugin](https://github.com/johnagan/clean-webpack-plugin)

  - 清除构建文件
  - **已经不需要，使用**：`clean: true,`

  ```javascript
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
      clean: true,
    },
  ```

- [copy-webpack-plugin](https://github.com/webpack-contrib/copy-webpack-plugin)

  - 复制资源文件
  - **已经不需要，webpack5 默认自动复制**



#### 压缩(Minification) 

> webpack v4+ will minify your code by default in [`production mode`](https://webpack.docschina.org/configuration/mode/#mode-production).

注意，虽然生产环境下默认使用 [`TerserPlugin`](https://webpack.docschina.org/plugins/terser-webpack-plugin) ，并且也是代码压缩方面比较好的选择，但是还有一些其他可选择项。以下有几个同样很受欢迎的插件：

- [`ClosureWebpackPlugin`](https://github.com/webpack-contrib/closure-webpack-plugin)

如果决定尝试一些其他压缩插件，确保新插件也会按照 [tree shake](https://webpack.docschina.org/guides/tree-shaking) 指南中所陈述的具有删除未引用代码(dead code)的能力，并将它作为 [`optimization.minimizer`](https://webpack.docschina.org/configuration/optimization/#optimization-minimizer)。



[**TerserWebpackPlugin**](https://webpack.docschina.org/plugins/terser-webpack-plugin/)

- 如果你使用的是 webpack v5 或以上版本，你不需要安装这个插件。webpack v5 自带最新的 `terser-webpack-plugin`。如果使用 webpack v4，则必须安装 `terser-webpack-plugin` v4 的版本。



**CSS 生产模式压缩** 

```shell
$ yarn add css-loader style-loader sass-loader sass -D
$ yarn add mini-css-extract-plugin css-minimizer-webpack-plugin -D
```

- 为了压缩输出文件，请使用类似于 [css-minimizer-webpack-plugin](https://webpack.docschina.org/plugins/css-minimizer-webpack-plugin/) 这样的插件。

  就像 [optimize-css-assets-webpack-plugin](https://github.com/NMFR/optimize-css-assets-webpack-plugin) 一样，但在 source maps 和 assets 中使用查询字符串会更加准确，支持缓存和并发模式下运行。

- 首先安装 `mini-css-extract-plugin`

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");
const TerserPlugin = require("terser-webpack-plugin");

module.exports = {
  mode: 'development',
  entry: {
    index: './src/index.js',
  },
  devServer: {
    contentBase: path.resolve(__dirname, 'dist'),
    hot: true,
  },
  optimization: {
    minimize: true, // 开发环境下启用 CSS 优化
    minimizer: [
      // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`），将下一行取消注释
      new CssMinimizerPlugin(),
      new TerserPlugin(),
    ],
  },
  module: {
    rules: [
      {
        test: /.s?css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'],
      },
      {
        test: /\.js$/,
        loader: 'babel-loader'
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      filename: 'index.html',
      template: './src/template.html',
    }),
    // 生成css文件
    new MiniCssExtractPlugin({
      filename: '[name].css',
      chunkFilename: '[id].css',
    })
  ],
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
    clean: true,
  },
};
```



### 4. 了解Gulp的核心概念，学习配置Gulp基础任务

易于使用 构建快速 插件系统 易于学习

![image-20210812141325838](大前端.assets/image-20210812141325838.png)

#### 压缩

[gulp-uglify](https://www.npmjs.com/package/gulp-uglify) 

[gulp-rename](https://www.npmjs.com/package/gulp-rename)

#### 清理

[gulp-dest-clean](https://www.npmjs.com/package/gulp-dest-clean)

- 或者	[gulp-clean](https://www.npmjs.com/package/gulp-clean)

[gulp-autoprefixer](https://www.npmjs.com/package/gulp-autoprefixer)

[gulp-sass](https://www.npmjs.com/package/gulp-sass)

[gulp-load-plugins](https://www.npmjs.com/package/gulp-load-plugins)

#### 热刷新

[browserSync](https://browsersync.io/docs/gulp#gulp-sass-css)

- `npm install -D browser-sync`
- gulpfile.js

```javascript
const { src, dest, series, watch } = require('gulp')
const browserSync = require('browser-sync').create();

// 压缩js
function js (cb) {
  console.log("Hello scripts!");
  // [gulp-uglify]
  src('js/*.js')
    .pipe(dest('./dist/js'))
    .pipe(browserSync.reload({ stream: true }))
  cb();
}

// 压缩scss
function css (cb) {
  // gulp-sass
  console.log("Hello styles!");
  src('css/*.css')
    .pipe(dest('./dist/css'))
    .pipe(browserSync.reload({ stream: true }))
  cb();
}

// 监听文件变化
function watcher (cb) {
  watch('js/*.js', js);
  watch('css/*.css', css);
  cb();
}

// 删除dist目录内容
function clean (cb) {
  // gulp-dest-clean
  console.log("clean!");
  cb();
}

// server 任务 // Static Server + watching scss/html files
function serve (cb) {
  browserSync.init({
    server: "./"
  });
  cb();
}

exports.scripts = js;
exports.styles = css;
exports.clean = clean;
exports.default = series([
  clean,
  js,
  css,
  serve,
  watcher
])
```



#### 图片

[gulp-imagemin](https://www.npmjs.com/package/gulp-imagemin)



### 5. 配置Yeoman脚手架工程项目

[Yeoman 起步](https://yowebapp.github.io/codelab/setup.html)

- `npm install -g yo`

[generator-generator](https://github.com/yeoman/generator-generator)

- 生成脚手架项目
- `npm install -g yo generator-generator`
- `yo generator`



### 6. 创建自己的脚手架工具

[generator-imooc-gulp](https://www.npmjs.com/package/generator-imooc-gulp)

- 已经上传到 npm 的脚手架

全局yo命令安装，安装命令yo< package>

- 脚手架的名称是 generator-打头，如：yo brian-imooc

使用 `generator-generator` 快速创建脚手架生成项目

- 全局安装 `npm install-g generator-generator`

- bower=false

使用npm进行发布

- link命令本地测试，发布时设置 npm registry



## 第4周 深入理解Vue 框架知识

 跟上企业需求的步伐，本周从MVVM框架基础讲起，让您拥有组件化思想，掌握目前流行的Vue框架进阶应用。重点不仅在于应用，也在于原理，做到知其然，知其所以然。
​ 课程安排：
### 1. Vue cli工具的使用，创建工程化项目

- 定义
  - MVVM（Model-view-viewmodel）是一种软件架构模式
    - 双向绑定的原理，使用到 Object.defineproperty
  - 组成部分
  - 模型、视图、视图模型

#### 创建工程化项目

```shell
npm install -g @vue/cli
# OR
yarn global add @vue/cli

npm install -g @vue/cli-service-global
```

```shell
vue create hello-world
# 空格键选择
vue create vue-begin # 使用上次保存的预设模板
```



#### Vue CLI命令扩展使用vue ui

可视化创建项目

**chrome 打开网页默认显示中文：**

```
chrome://settings/?search=%E8%AF%AD%E8%A8%80
中文→移到顶部
```



#### vue工程中 Webpack 配置

[webpack 相关](https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F)

- **链式操作 (高级)**

  - 修改 Loader 选项

  ```javascript
  // vue.config.js
  module.exports = {
    chainWebpack: config => {
      config.module
        .rule('vue')
        .use('vue-loader')
          .tap(options => {
            // 修改它的选项...
            return options
          })
    }
  }
  ```

  - 添加一个新的 Loader

  ```js
  // vue.config.js
  module.exports = {
    chainWebpack: config => {
      // GraphQL Loader
      config.module
        .rule('graphql')
        .test(/\.graphql$/)
        .use('graphql-tag/loader')
          .loader('graphql-tag/loader')
          .end()
        // 你还可以再添加一个 loader
        .use('other-loader')
          .loader('other-loader')
          .end()
    }
  }
  ```

  - [#](https://cli.vuejs.org/zh/guide/webpack.html#替换一个规则里的-loader)替换一个规则里的 Loader

  如果你想要替换一个已有的[基础 loader](https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-service/lib/config/base.js)，例如为内联的 SVG 文件使用 `vue-svg-loader` 而不是加载这个文件：

  ```js
  // vue.config.js
  module.exports = {
    chainWebpack: config => {
      const svgRule = config.module.rule('svg')
  
      // 清除已有的所有 loader。
      // 如果你不这样做，接下来的 loader 会附加在该规则现有的 loader 之后。
      svgRule.uses.clear()
  
      // 添加要替换的 loader
      svgRule
        .use('vue-svg-loader')
          .loader('vue-svg-loader')
    }
  }
  ```

  - [#](https://cli.vuejs.org/zh/guide/webpack.html#修改插件选项)修改插件选项

  ```js
  // vue.config.js
  module.exports = {
    chainWebpack: config => {
      config
        .plugin('html')
        .tap(args => {
          return [/* 传递给 html-webpack-plugin's 构造函数的新参数 */]
        })
    }
  }
  ```

#### [全局 CLI 配置参考](https://cli.vuejs.org/zh/config/#%E5%85%A8%E5%B1%80-cli-%E9%85%8D%E7%BD%AE)

#### [代理 devServer.proxy](https://cli.vuejs.org/zh/config/#devserver-proxy)

告诉开发服务器将任何未知请求 (没有匹配到静态文件的请求) 代理到 `<url>`。

```javascript
// vue.config.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: '<url>',
        ws: true,
        changeOrigin: true
      },
      '/foo': {
        target: '<other_url>'
      }
    }
  }
}
```



[`Vetur can't find tsconfig.json or jsconfig.json in /home/ubuntu.`](https://vuejs.github.io/vetur/guide/FAQ.html#vetur-can-t-find-tsconfig-json-jsconfig-json-in-xxxx-xxxxxx)



#### Vue 工程目录

简要说明

- `main.js`主入口，`router.js`路由划分
- `plugins` 自己或第三方插件,包括但不限于components、directives、filters、third lib
- `pages` 所有路由页面。原则：轻page，重component
- `components` 所有组件。包括原子组件、业务公用组件、页面独有组件
- `server` api引入入口
- `assets` sass、图片资源入口，不常修改数据
- `utils` 工具文件夹
- `store` 标准vuex格式，非必须

[#](https://lq782655835.github.io/blogs/team-standard/recommend-vue-project-structure.html#详细说明)详细说明

```text
project
└───src
│   │   app.vue    // 主页面
│   │   main.js    // 主入口
|   |   router.js  // 所有路由
│   │
│   |____assets    // css、image、svg等资源
│   |   |____css   // 所有sass资源
|   |   |    |  reset.scss       // 兼容各浏览器
|   |   |    |  global.scss      // 全局css
|   |   |    |  variable.scss    // sass变量和function等
│   |   |____img   // image图标库
|   |   |____svg   // svg图标库
|   |
|   |____components    // 组件
│   |   |____common    // common自注册组件
│   |        |____base // 原子组件(如果是引入第三方，该文件夹可省略)
│   |        |   ...   // 业务公用组件
│   |   |____entity    // entity页面组件
│   |   |____about     // about页面组件
|   |
|   |____pages     // UI层(原则：轻page，重component)
|   |   |____entity
|   |   |    |  list.vue      // 列表页
|   |   |    |  create.vue    // 新增页
|   |   |    |  edit.vue      // 修改页
|   |   | main.vue
|   |
|   |____plugins   // 自己或第三方插件
|   |   | index.js       // 插件入口文件
|   |   | directives.js  // 所有Vue指令
|   |   | filters.js  // 所有Vue过滤
|   |
|   |____server    // 接口层
|   |   | index.js   // 所有接口
|   |   | http.js  // axios二次封装
|   |
|   |____store     // vuex数据
|   |   | index.js
|   |
|   |____utils     // 工具层
|   |   | config.js// 配置文件，包括常量配置
|
└───public         // 公用文件，不经过webpack处理
│   │   favicon.ico
│   │   index.html
│   vue.config.js  // vue-cli3主配置
│   babel.config.js// babel配置
│   .eslintrc.js   // eslint配置
│   .prettierrc.js // perttier配置
│   package.json   // npm配置
│   README.md      // 项目说明
```



#### [在 VS Code 中调试](https://cn.vuejs.org/v2/cookbook/debugging-in-vscode.html)

在可以从 VS Code 调试你的 Vue 组件之前，你需要更新 webpack 配置以构建 source map。做了这件事之后，我们的调试器就有机会将一个被压缩的文件中的代码对应回其源文件相应的位置。这会确保你可以在一个应用中调试，即便你的资源已经被 webpack 优化过了也没关系。

如果你使用的是 Vue CLI 3，请设置并更新 `vue.config.js` 内的 `devtool` property：

```javascript
module.exports = {
  configureWebpack: {
    devtool: 'source-map'
  }
}
```

```json
// launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "chrome",
      "request": "launch",
      "name": "vuejs: chrome",
      "url": "http://localhost:8080",
      "webRoot": "${workspaceFolder}/src",
      "breakOnLoad": true,
      "sourceMapPathOverrides": {
        "webpack:///src/*": "${webRoot}/*"
      }
    },
    {
      "type": "firefox",
      "request": "launch",
      "name": "vuejs: firefox",
      "url": "http://localhost:8080",
      "webRoot": "${workspaceFolder}/src",
      "pathMappings": [{ "url": "webpack:///src/", "path": "${webRoot}/" }]
    }
  ]
}
```

**不能同时使用 VSCode 调试和 devtool**



#### [替代方案 devtools](https://cn.vuejs.org/v2/cookbook/debugging-in-vscode.html#替代方案)

控制台输入

```
this.msg
"Welcome!"
```

Autoload vuex state on



### 2. 理解组件化思想

- 组件化是指将页面的功能模块进行拆分，封装。
- 组件代码包含了组件所有的功能代码与样式。
- 组件化的作用是复用、高可维护；
- 组件化不局限于前端代码，而是一种设计思想。

#### 组件化原则

- 独立功能模块（松耦合、扁平化、提炼精华）
- 独立的状态变化（统一的状态管理）
- 从上而下的逻辑思考，从下而上的组件拆分

#### 组件化带来的问题

- 传统开发vs单页面应用
- 代码维护&代码管理&代码规范
- 组件通信、组件传参



### 3. Vue基础、路由及状态管理

#### vue基础

- vue.js 组件组成 （template，script，style）
- 模板语法（文本、属性）、条件渲染v-if、列表渲染v-for
- 事件处理v-on（@简写）、计算属性 computed

Vue.js核心组件

- 路由组件 Vue-Router

#### [Vue2.5零基础入门到实战开发去哪儿网App](https://github.com/Eished/Vue_notes/blob/master/vue-travel去哪儿网.md)

官方文档+vue基础应用教程



### 4. Vue、Vue-router、Vuex综合应用

单向数据流及状态管理Vuex



# 阶段二：抓住团队协作的密码

## 第5周 前端框架分类及选型

 是否还在为选择使用什么框架而苦恼？是否还在为学习哪个前端框架而纠结？本周将给您满意的答案，有UI和JS框架对比与选型，有Node.js进阶使用、Web框架如何开发RESTful接口等。
 课程安排：

### 1. 常见MVVM与UI框架对比与选型

#### 前端框架分类及对比

- 类库：JQuery，**Lodash**（Underscore）
- JS 库： **React, Vue, Angular**, Ext JS, Backbone
- 工具：Webpack（Build），Jest（Test），ELInt（Lint）， Template（ES）
- 应用类：（Echarts/D3/three）

**框架与库的区别**

- 框架：框架主动调用用户代码，包含库
- 库：功能模块集合，需用户主动调用



#### UI框架选型

- 判断使用场景（PC，移动Web，小程序，响应式）
- 组件丰富，成熟的模板，方便集成
- 成熟的社区，成熟的生态

[**LayUI**](https://www.layui.com/)

已淘汰

[**iView**](https://www.iviewui.com/)

更新频率低，部分收费



[**Ant Design**](https://ant.design/index-cn)

企业推荐使用，内容丰富

https://antdv.com/docs/vue/introduce-cn/



[**Element UI**](https://element.eleme.cn/)

推荐使用，较轻量

https://element.eleme.cn/#/zh-CN



[**vuetify**](https://vuetifyjs.com/zh-Hans/)

Vuetify 是建立在Vue.js之上的完备的界面框架。

个人项目推荐



#### 移动端UI框架

**Mint UI**



**Cube UI**



**Vant**

推荐使用

https://vant-contrib.gitee.io/vant/#/zh-CN/



#### JS框架选型

- 团队的技术能力
- 应用场景（后台？性能要求？时间要求？）
- 成熟的社区，成熟的生态

Vue的Star数量最多，成长最快，但是主要还是国内使用的多

主要原因：方便集成、学习成本低

- 根据团队技术能力选择框架，按需取用
- 了解框架背后的原理，并思考如何自己实现一个JS框架
- 多读文档，求助社区，高效开发



### 2. Koa框架后台项目的配置及ES6语法支持

[express 和 koa2 教程笔记](https://github.com/Eished/node_blog_notes)

[koa 官网](https://koajs.com/)

[koa 官网 中文版](https://koa.bootcss.com/)

```
$ npm i koa -S
$ npm i koa-router -S
```



#### Koa核心概念

![image-20210816094453812](大前端.assets/image-20210816094453812.png)

洋葱模型



### 3. Koa工作原理及常见Koa中间件使用

- 路由：koa-router
- 协议解析：koa-body
- 跨域处理：@koa/cors



#### RESTfu接口示例

格式化返回的 JSON 数据

```
npm i koa-json -S
```

- 常见的GET/POST
- 统一的数据处理
- 接口调试及日志输出



### 4. 如何调试Node应用及webpack配置

#### 开发目录结构

- 按照功能模块进行区分
- 路由压缩（合并，避免多次use）：`koa-combine-routers`
- 静态资源：`koa-static`
- 安全请求头：`koa-helmet` 



#### 热加载和Webpack

- 热加载，监视文件变化，自动刷新：`npm install -g nodemon`

  - 配置 package.json -> script -> `nodemon index.js`

- 安装 Webpack，见前面章节

  - `npm i -D webpack-node-externals babel/core babel/node babel/preset-env babel-loader cross-env`

- 配置完就**可以使用 ES6 语法，由 babel 转换为 ES5**

  - nodemon 默认 common.js 语法，ES6：`nodemon --exec`

  - 配置 webpack.config.js -> script ->

    ```
    {
    	"start": "nodemon --exec babel-node src/index. js",
    	"webpack:debug": "node --inspect-brk ./node_modules/bin/webpack --inline --progress" // chrome调试webpack配置
    }
    ```

  - 可以在 VSCode 里调试 webpack 配置，或者 node.js 代码

#### Webpack 配置优化

- 检查更新包：`npm-check-updates`

  - 查看可更新：`ncu`
  - 更新：`ncu -u to upgrade package.json`
  - 删掉nodemodules文件夹，再安装。或者卸载更新过的包。

- 整合中间件：`koa-compose`

  - 传中间件数组

- 代码压缩：`koa-compress`

- 设置不同环境的webpack配置：

  ```
  webpack.config.base.js 
  webpack.config.dev.js 
  webpack.config.prod.js
  ```

  - 根据环境变量，自动切换配置插件：webpack.DefinePlugin()
  - 合并配置文件：`webpack-merge`
    - 设置合并条件

- 压缩 JS 代码：TerserWebpackPlugin，生产环境默认，见前章。

- 避免重复依赖插件：SplitChunksPlugin

```
// package.json
"scripts": {
  "start": "nodemon --exec babel-node src/index. js", 
  "webpack:debug":"node --inspect-brk ./node_modules/bin/webpack --inline --progress", 
  "build": "cross-env NODE_ENV=prod webpack --config config/webpack --config.prod.js"
} 
```

可以不使用webpack，只用babel兼容新语法。

不需要整合成一个JS文件。

后端不一定需要压缩。



### 5. 登录模块的需求分析及流程设计

- 布局：
  - flex
  - float
- vue框架
  - 路由
    - 懒加载
  - 组件拆分
- 业务模块：
  - 登录
    - 输入验证
    - 拦截非正常请求
  - 注册
    - 输入验证
    - 拦截非正常请求
    - 用户基本信息
  - 找回密码
    - 邮件服务
      - NodeMailer
    - 短信
    - 密码提问

#### 需求分析

1. 功能需求，需求拆解
   1. 用户输入验证
   2. 拦截非正常的登录请求
   3. 登录验证（验证机制）：token
2. 流程图及原型图的绘制
3. 形成文档

流程图：![image-20210816171250379](大前端.assets/image-20210816171250379.png)原型图：![image-20210816171320230](大前端.assets/image-20210816171320230.png) 

### 6. 登录模块的开发，LayUI框架集成

#### 组件拆分

![image-20210816205707656](大前端.assets/image-20210816205707656.png)



### 7. 邮件服务和图片验证码服务的开发

#### 图片验证码

```
npm i svg-captcha
```

- Vue 使用 axios 请求验证码

#### 邮件服务



### 8. 表单验证Vuelidate/VeeValidate

```
npm install vuelidate --save
```

或者

```
VeeValidate // 这个更好用
```



### 9. 配置邮件服务NodeMailer

```
npm i nodemalter
```

- 邮件服务注意
  - 使用客户端授权码，QQ邮箱14天限制
  - 公共邮箱限制了发送频次、数量、群发
  - 邮件服务：阿里云/亚马逊/SES/Sendcloud



### 10. 邮件服务接口与找回密码对接

#### 时间日期处理

```
npm install moment
```

#### 跨域问题

前章 webpack 相关内容，使用 vue.config.js 配置 webpack 

```
devserver: {
	proxy: "http://locathost:3000"
}
```

前端解决跨域

总结：

- 公共邮箱限制，使用授权码
- 开发接口Api：业务->路由->测试接口->前端页面
- devServer处理开发过程中的跨域问题



## 第6周 团队协作-文档与版本管理

项目开发过程中，少不了团队协作，那团队协作有哪些可以提升效率？团队协作第一弹：从文档管理、版本控制开始，我们了解Git flow和文档的管理办法，搭建团队的文档管理工具，提升工作效率。
课程安排：

#### **敏捷流程：**

- 文档管理
  - 文档分类
    - 接口
    - 项目
    - 需求
    - 标准类（规范）
  - 文档管理工具
    - 协同工具
      - 国内（GoogleDoc）
      - 国外（石墨）
    - 接口文档
      - ShowDoc（本地部署）
    - 其它
      - gitbook
      - blog（hexo）
      - 注释产出Api文档（swagger、apidoc）
      - mock（rap、apijson）
    - 功能分类
      - 协同
      - 版本控制
      - 在线编辑
      - 文件保存
      - 分享
      - 本地化部署
  - MarkDown
    - 语法
    - 工具
      - Typora
- 版本管理
- 缺陷控制
- 自动化

### 1. Markdown语法及进阶图表使用

笔记：[Markdown_notes](https://github.com/Eished/Markdown_notes)

### 2. ShowDoc进行云笔记及文档管理

- 接口模板、分组
- 权限控制、团队协作
- 版本控制、本地部署

推荐使用

#### Show Doc简介

- 数据字典、接口模版
- 团队协作
- 免费开源

#### 安装

本地化部署：https://showdoc.cc

Docker方式安装



3. 搭建自己团队的接口管理平台



### 4. 学会使用hexo+github搭建自己的博客

https://iknow.fun

### 5. 掌握Git基础命令

![image-20210816222941706](大前端.assets/image-20210816222941706.png)

![image-20210816223003975](大前端.assets/image-20210816223003975.png)

![image-20210816223107321](大前端.assets/image-20210816223107321.png)

![image-20210816225055033](大前端.assets/image-20210816225055033.png)



笔记：[git_notes](https://github.com/Eished/git_notes)

6. 从零配置github到SSH秘钥克隆仓库

### 7. Git Flow及管理版本控制

#### 经典模型的问题

- 必须使用dev分支
- 复杂度高：hotfix与 release分支
- 多次 Merge合并

![image-20210816223527349](大前端.assets/image-20210816223527349.png)



#### Git Flow

- 适用于**持续集成**多环境场景
- 上游分支向下游发展
- 流程：Bug-> New branch-> master->pre branch->target branch

![image-20210816223559798](大前端.assets/image-20210816223559798.png)

- 适用于**版本项目**
- 稳定版本从 maste检出bug修复在分支
- 流程：master-> Stable->new branch->bug fix->version

![image-20210816223704091](大前端.assets/image-20210816223704091.png)



### 8. 使用Docker快速搭建gitlab平台

- Docker，**Docker-compose快速创建**
  - 两份 gitlabl的 docker-compose配置文件（官方/github）
- 配置 gitlab，备份/还原
- 其他：邮件配置、Https配置



### 9. gitlab平台管理，用户权限控制

- 以组为单元，设置管理员
- 熟悉 Merge Request，写好 git commit
- 及时回收权限，或者设置过期时间



## 第7周 团队协作-缺陷控制与自动化流程

项目质量决定了项目的命运，如何做好缺陷控制，是每个团队非常头疼的问题。本周学习团队协作第二弹：缺陷控制及前端自动化流程，使用容器技术配置自动化/持续集成环境，进一步提升团队效率。
课程安排：

### 1. 了解缺陷控制方法
### 2. 掌握缺陷控制工具及使用
### 3. 了解质量管理工作流
### 4. 理解自动化/持续集成流程，升华DevOps理解
### 5. 学习搭建、配置Jenkins服务
### 6. 掌握Jenkins中的权限控制，并与gitlab进行集成
### 7. 学习Jenkins的权限控制与插件管理系统

## 第8周 团队协作-配置前后端自动化任务。

Docker仓库的进阶使用，搭建私有Docker仓库，并配置Jenkins的前后端自动化流程，感受自动化构建的魅力。
课程安排：

### 1. 掌握容器技术Docker进阶使用
### 2. 快速搭建Jenkins平台
### 3. 私有化容器平台Harbor搭建及使用
### 4. 运用Jenkins任务配置，自动化流程
### 5. 自定义Shell脚本
### 6. 配合Jenkins效率构建，完成发布、构建等工作

# 阶段三：打通全栈开发技能

## 第9周 NoSQL数据库的设计与集成（MongoDB/Redis）

 本周带您解开数据之谜，学习NoSQL数据库与数据库设计原则。让您带着设计思维去设计项目数据库，搞定Redis服务搭建与集成，完成具备鉴权功能的登录页面后端开发，综合应用Koa中间件。
 课程安排：

### 1. 了解NoSQL数据库分类及选型
### 2. 掌握数据库设计原则
### 3. 掌握从功能到数据库的基本设计
### 4. 常见MongoDB及Redis与nodejs集成
### 5. 使用Docker快速搭建MongoDB及Redis开发测试环境
### 6. 登录鉴权机制及koa进阶
### 7. JWT方式鉴权接口开发

## 第10周 全栈开发-首页与发帖模块开发

 本周综合前面的知识进行实战，从前端到数据库、接口设计再到组件拆分，最后核心功能实现，进一步加深Vue-router、Vuex进阶应用，实现前&后端全栈页面开发。
 课程安排：

### 1. 掌握首页数据库设计、接口设计、文档更新
### 2. 首页列表、筛选、排序功能开发
### 3. 首页侧栏开发：统计、签到、周热议
### 4. 发帖编辑器自定义开发
### 5. 图片上传功能
### 6. 发帖功能：插入链接|图片、引用|代码样式、预览
### 7. MongDB多表联合查询及统计SQL
### 8. 发贴权限效验

## 第11周 全栈开发-用户中心模块

继续进行核心模块开发，本周将会开发PC用户中心模块，从数据库与接口设计，到消息中心、我的主页、帖子、收藏、用户信息等功能开发，用实战去检验学习效果。
课程安排：

### 1. 设计中心路由及页面跳转
### 2. 头像上传、密码修改、邮箱激活
### 3. 实战“我”发表的帖子列表
### 4. 收藏功能开发；收藏的帖子列表
### 5. 签到功能开发；会员信息、快捷链接
### 6. 搭建WebSocket服务，实时显示用户消息提醒

## 第12周 性能优化-服务端渲染

 性能是评判项目好坏标准之一，本周将带着大家进入性能优化环节，学习配置服务器端渲染思想及Nuxt.js使用，并对前面项目进行改造，让项目的性能更优。
 课程安排：

### 1. 了解SEO优化方法
### 2. 前端性能优化思想
### 3. 前端性能优化之服务端渲染
### 4. Nuxt
### 5. 改造前端项目的功能模块

# 阶段四：前后端分离的后台管理系统

## 第13周 后台管理系统-发帖管理开发

 本周开始进入后台管理系统开发，第一步：从需求分析、界面设计、接口设计、数据库设计，到发帖管理功能模块开发，及发帖管理接口对接，让项目开始具备完善的管理系统。
 课程安排：

### 1. 技术框架选型及UI框架选型
### 2. 后端需求分析，接口设计，数据库设计
### 3. iView-admin框架集成
### 4. 解析项目架构，添加路由和菜单
### 5. 定制开发登录入口，加入JWT鉴权机制
### 6. Cookie及Session的使用方式
### 7. 实战多语言场景：英文&简体中文

## 第14周 后台管理系统-文章与用户管理开发

 本周进行后台管理系统开发第二步：从需求分析、接口与数据库设计，到文章与用户管理两大重要功能模块开发，与Node的后台进行接口对接，轻松实现文章和用户管理，系统功能进一步升级。
 课程安排：

### 1. 使用ShowDoc定义接口文档
### 2. 使用DOClever开发测试接口
### 3. 设计初步的数据结构，返回的数据类型及Mock数据
### 4. 文章管理、角色管理界面的模态框、页面样式开发
### 5. Node

## 第15周 后台管理系统—首页管理与日志服务开发

继续学习，后台管理系统开发第三步：完成后端管理平台的首页管理，对首页统计功能进行定制开发，并增加日志服务，对后台接口的调用增加日志管理，实现系统功能完善与监管。
课程安排：

### 1. 用户权限设计
### 2. 首页管理定制接口、数据库设计
### 3. 实现日志服务的配置与定制化
### 4. 后端首页的可视化解决方案
### 5. 图表设计及数据接口开发

## 第16周 前后端联调必备通用技能

只停留在开发还远远不够，如何进行前后端联调，并正常运行很重要。本周学习前后端联调及细节优化，定制Jenkins任务及配置前后端自动化任务。并学习移动端应用开发的痛点问题及开发基础。
课程安排：

### 1. 掌握前后端联调技能
### 2. Jenkins配置前后端项目的自动化
### 3. 项目运行维护阶段的注意事项
### 4. 版本控制及迭代升级流程
### 5. WebApp原型设计及工具使用
### 6. WebApp开发基础：布局、适配、性能优化等
### 7. WebApp开发的常见问题

# 阶段五：流行的WebApp与小程序开发

## 第17周 WebApp页面设计与开发。

 随着终端设备的发展，在移动端浏览Web已成主流。本周继续进行WebApp功能模块开发：登录页面、首页及个人中心开发，学习了解消息机制，移动端消息开发。
 课程安排：

### 1. 原型工具页面设计
### 2. 移动端如何进行适配
### 3. 开发登录、注册、密码找回页面
### 4. 首页、个人中心开发
### 5. 发帖、消息页面开发

## 第18周 WebApp前后端联调。

 WebApp页面开发只是第一步，如何和后端对接，掌握从后台管理到前端展现的整体解决方案，提升技能和解决实际问题的能力更为重要。
 课程安排：

### 1. 与后端接口进行对接
### 2. 上拉加载、下拉刷新的开发技巧
### 3. 消息功能设计技巧
### 4. WebSocket服务搭建及使用
### 5. 个人中心对接功能实战

## 第19周 小程序基础

 本周介绍小程序的开发适用场景，实操小程序的注册流程，掌握开发中的注意事项、学习小程序原生框架基本用法，快应用开发框架的使用，并且能够独立调试开发小程序。
 课程安排：

### 1. 了解小程序注册流程
### 2. 了解小程序注册方式及注册主体
### 3. 了解跨端框架适用场景及开发工作流
### 4. 掌握小程序开发环境配置
### 5. 掌握小程序本地化调试办法
### 6. 掌握快应用场景：mpvue/wepy基础

## 第20周 小程序进阶

 学习如何配置小程序、小程序的生命周期，以及如何使用第三方的组件库，提升小程序的应用能力。
 课程安排：

### 1. 掌握小程序面板配置，如何配置app
### 2. 了解小程序的生命周期
### 3. 多页面下的开发工作流及目录结构
### 4. 使用npm第三方依赖包
### 5. 常见的API接口（HTTP请求、缓存）
### 6. 上拉加载、下拉刷新如何使用及使用场景

## 第21周 小程序-首页、登录、菜单定制开发

 小程序开发实战第一部分，学习首页的列表开发、菜单定制的开发、微信接口及数据库的设计。
 课程安排：

### 1. 了解wepy/mpvue框架基础
### 2. 了解小程序工程化项目
### 3. 掌握小程序常用组件（轮播、卡片、导航）
### 4. 掌握小程序后台管理界面和设置
### 5. 掌握开发基础及版本管理
### 6. 前后端接口对接HTTPS设置
### 7. 业务模块的开发：首页、菜单、登录

## 第22周 小程序-详情、编辑与发帖、个人中心开发

 小程序开发实战第二部分，学习个人中心、详情页面、编辑发帖等业务模块的功能开发，以及如何与后台接口进行对接，完成页面的整体功能调试。
 课程安排：

### 1. 小程序页面设计思想
### 2. 小程序自定义组件
### 3. WebSocket服务搭建
### 4. 消息功能的接口设计
### 5. 掌握消息机制
### 6. 详情、个人中心模块开发
### 7. 编辑与发帖模块开发

## 第23周 项目部署与运维

 介绍云服务器、域名及HTTPS服务、项目运维及Linux相关自启脚本介绍、项目更新及日志处理、如何发送报警通知及应急策略的制定。
 课程安排：

### 1. 如何进行服务器监控、服务器日志及报警
### 2. 理解域名服务及HTTPS
### 3. 了解购买云服务器及管理
### 4. 能编写基本的运维脚本
### 5. 能项目运行维护/更新终止
### 6. 了解项目总结及资源回收
### 7. 如何进行项目重构

## 第24周 全面汇总与未来展望

 课程整体重要知识点回顾，全周期流程回顾，以及未来技术展望，如TypeScript进行项目重构与vue3.x进行兼容对接；混合应用框架；跨端应用框架；桌面应用Electron等，做好未来发展指引。
 课程安排：

### 1. 重点知识回顾
### 2. 开发流程回顾
### 3. 趋势技术的介绍与指引
### 4. 面试中的技巧总结

